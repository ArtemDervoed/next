{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/Users/msi/hello-next/components/Sphere/Sphere.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport fragmentShader from './fragment.glsl';\nimport vertexShader from './vertex.glsl';\nimport * as THREE from 'three';\nimport OrbitControls from 'three-orbitcontrols'; // import TRYGalien from './TRYGalien.woff2';\n\nexport default class Sphere extends React.PureComponent {\n  constructor() {\n    super();\n\n    _defineProperty(this, \"handleMouseMove\", e => {\n      this.mouse.x = e.clientX / window.innerWidth * 2 - 1;\n      this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n    });\n\n    _defineProperty(this, \"animate\", () => {\n      this.renderer.render(this.scene, this.camera);\n      this.pMaterial.uniforms.iTime.value = this.time * 0.175;\n      this.time++;\n      requestAnimationFrame(this.animate);\n    });\n\n    this.time = 0;\n    this.mouse = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  componentDidMount() {\n    console.log(vertexShader);\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setClearColor('hsl(100, 10%, 10%)', 1);\n    this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);\n    this.camera.position.set(2, -1.5, -1);\n    this.camera.lookAt(new THREE.Vector3());\n    this.scene = new THREE.Scene();\n    this.camera.position.z = 5;\n    this.renderer.setSize(this.width, this.height);\n    this.canvas.appendChild(this.renderer.domElement);\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.controls.enableDamping = true;\n    this.controls.dampingFactor = 0.25;\n    this.controls.enableZoom = false;\n    this.particles = new THREE.OctahedronGeometry(1, 5);\n    this.particles.vertices = this.particles.vertices.map(v => {\n      v.x += (Math.random() - 0.5) * 0.05;\n      v.y += (Math.random() - 0.5) * 0.05;\n      v.z += (Math.random() - 0.5) * 0.05;\n      return v;\n    });\n    this.shaderPoint = THREE.ShaderLib.points;\n    this.uniforms = _objectSpread({}, this.shaderPoint.uniforms, {\n      iTime: {\n        value: 0\n      },\n      pSize: {\n        value: 10\n      }\n    });\n    this.pMaterial = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      transparent: true,\n      depthWrite: false,\n      blending: THREE.AdditiveBlending,\n      fragmentShader: `\n        precision highp float;\nvarying vec3 vpos;\nvarying float hp;\nvarying float hp2;\nvarying float hp3;\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float pSize;\nuniform mat3 uvTransform;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\n  float t = iTime*.5 + hp; // Делаем время для точки такое же как в vertexShader\n  \n  float g = length(uv) * pSize;\n  float gx = .05 / smoothstep(.0, pSize, g);\n  \n  float tr = step(.3, hp2);\n  if(tr == 0.){\n    // Для отрывающихся точке будем делать затухание\n    tr = 1. - fract(t);\n  }\n  // Прозрачность считаем от hp3 чтоб все точки были с разной яркостью\n  fragColor = vec4(vec3(gx) / g, hp3 * tr);\n}\nvarying vec2 vUv;\n\nvoid main() {\n    mainImage(gl_FragColor, vUv * iResolution.xy);\n    // gl_FragColor = vec4(1., 0., 0., 1.);\n}`,\n      vertexShader: `\n        #pragma glslify: noise = require('glsl-noise/simplex/3d')\n\nvarying vec2 vUv;\nvarying vec3 vpos;\nvarying float hp;\nvarying float hp2;\nvarying float hp3;\nuniform float iTime;\nuniform float pSize;\n\nfloat hash(vec3 p)// replace this by something better\n{\n  p  = fract(p*0.3183099+.1);\n  p *= 17.0;\n  return fract(p.x*p.y*p.z*(p.x+p.y+p.z));\n}\nvoid main() {\n  vUv = uv;\n  \n  hp = hash(position); // Рандомный фактор для точки по позиции\n  hp2 = hash(position*3.3); // Дополнительный рандомный фактор\n  hp3 = hash(position*6.6); // Еще один рандомный фактор\n  \n  float t = iTime*.5 + hp; // Замедляем время и прибавляем рандомный фактор - у этой точки будет \"своё\" время\n  vpos = position;\n  // индивидульный рандомнеый vec3 для точки для определения движения точки\n  vec3 npp = vec3(hash(position), hash(position*10.), hash(position*20.))*2.;\n  \n  // Фактор смещения через симплексный шум\n  float nF = noise((npp + vec3(iTime*.525)) * 1.) * (.25 + fract(t))*.5;\n  \n  // фактор движения - определяем только часть точек которые будут летать\n  float mF = step(hp2, .3);\n  \n  // Дивгаем точки (те которые попали в mF, остальные на месте)\n  vpos.xyz = vpos.xyz + (vpos.xyz * fract(t)*2. ) * mF;\n  // Добавляем к отлетающей точке фактор плавающего смещения\n  vpos.xyz += nF * mF;\n  \n  gl_PointSize = pSize;\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4( vpos, 1.0 );\n}`\n    });\n    this.particleSystem = new THREE.Points(this.particles, this.pMaterial);\n    this.particleSystem.sortParticles = true;\n    this.scene.add(this.particleSystem);\n    window.addEventListener('mousemove', this.handleMouseMove);\n    this.animate();\n  }\n\n  render() {\n    return __jsx(\"div\", {\n      ref: node => {\n        this.canvas = node;\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 169\n      },\n      __self: this\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/msi/hello-next/components/Sphere/Sphere.js"],"names":["fragmentShader","vertexShader","THREE","OrbitControls","Sphere","React","PureComponent","constructor","e","mouse","x","clientX","window","innerWidth","y","clientY","innerHeight","renderer","render","scene","camera","pMaterial","uniforms","iTime","value","time","requestAnimationFrame","animate","componentDidMount","console","log","width","height","WebGLRenderer","setClearColor","PerspectiveCamera","position","set","lookAt","Vector3","Scene","z","setSize","canvas","appendChild","domElement","controls","enableDamping","dampingFactor","enableZoom","particles","OctahedronGeometry","vertices","map","v","Math","random","shaderPoint","ShaderLib","points","pSize","ShaderMaterial","transparent","depthWrite","blending","AdditiveBlending","particleSystem","Points","sortParticles","add","addEventListener","handleMouseMove","node"],"mappings":"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","sourcesContent":["import fragmentShader from './fragment.glsl'\nimport vertexShader from './vertex.glsl';\n\nimport * as THREE from 'three';\nimport OrbitControls from 'three-orbitcontrols';\n\n// import TRYGalien from './TRYGalien.woff2';\n\nexport default class Sphere extends React.PureComponent {\n  constructor() {\n    super();\n    this.time = 0;\n    this.mouse = {\n      x: 0,\n      y: 0,\n    }\n  }\n  componentDidMount() {\n    console.log(vertexShader);\n    \n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n\n    this.renderer = new THREE.WebGLRenderer();\n\n    this.renderer.setClearColor('hsl(100, 10%, 10%)', 1);\n\n\n    this.camera = new THREE.PerspectiveCamera( 75, this.width / this.height, 0.1, 1000 );\n    this.camera.position.set(2, -1.5, -1);\n\n    this.camera.lookAt(new THREE.Vector3());\n\n    this.scene = new THREE.Scene();\n\n    this.camera.position.z = 5;\n    this.renderer.setSize(this.width, this.height);\n    this.canvas.appendChild(this.renderer.domElement);\n    \n    this.controls = new OrbitControls(this.camera, this.renderer.domElement)\n    this.controls.enableDamping = true\n    this.controls.dampingFactor = 0.25\n    this.controls.enableZoom = false\n\n    this.particles = new THREE.OctahedronGeometry(1, 5);\n    this.particles.vertices = this.particles.vertices.map(v => {\n        v.x += (Math.random() - 0.5) * 0.05;\n        v.y += (Math.random() - 0.5) * 0.05;\n        v.z += (Math.random() - 0.5) * 0.05;\n        return v;\n    });\n\n    this.shaderPoint = THREE.ShaderLib.points;\n    this.uniforms = {\n        ...this.shaderPoint.uniforms,\n        iTime: { value: 0 },\n        pSize: { value: 10 },\n    };\n\n    this.pMaterial = new THREE.ShaderMaterial({\n        uniforms: this.uniforms,\n        transparent: true,\n        depthWrite: false,\n\n        blending: THREE.AdditiveBlending,\n\n        fragmentShader: `\n        precision highp float;\nvarying vec3 vpos;\nvarying float hp;\nvarying float hp2;\nvarying float hp3;\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float pSize;\nuniform mat3 uvTransform;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\n  float t = iTime*.5 + hp; // Делаем время для точки такое же как в vertexShader\n  \n  float g = length(uv) * pSize;\n  float gx = .05 / smoothstep(.0, pSize, g);\n  \n  float tr = step(.3, hp2);\n  if(tr == 0.){\n    // Для отрывающихся точке будем делать затухание\n    tr = 1. - fract(t);\n  }\n  // Прозрачность считаем от hp3 чтоб все точки были с разной яркостью\n  fragColor = vec4(vec3(gx) / g, hp3 * tr);\n}\nvarying vec2 vUv;\n\nvoid main() {\n    mainImage(gl_FragColor, vUv * iResolution.xy);\n    // gl_FragColor = vec4(1., 0., 0., 1.);\n}`,\n        vertexShader: `\n        #pragma glslify: noise = require('glsl-noise/simplex/3d')\n\nvarying vec2 vUv;\nvarying vec3 vpos;\nvarying float hp;\nvarying float hp2;\nvarying float hp3;\nuniform float iTime;\nuniform float pSize;\n\nfloat hash(vec3 p)// replace this by something better\n{\n  p  = fract(p*0.3183099+.1);\n  p *= 17.0;\n  return fract(p.x*p.y*p.z*(p.x+p.y+p.z));\n}\nvoid main() {\n  vUv = uv;\n  \n  hp = hash(position); // Рандомный фактор для точки по позиции\n  hp2 = hash(position*3.3); // Дополнительный рандомный фактор\n  hp3 = hash(position*6.6); // Еще один рандомный фактор\n  \n  float t = iTime*.5 + hp; // Замедляем время и прибавляем рандомный фактор - у этой точки будет \"своё\" время\n  vpos = position;\n  // индивидульный рандомнеый vec3 для точки для определения движения точки\n  vec3 npp = vec3(hash(position), hash(position*10.), hash(position*20.))*2.;\n  \n  // Фактор смещения через симплексный шум\n  float nF = noise((npp + vec3(iTime*.525)) * 1.) * (.25 + fract(t))*.5;\n  \n  // фактор движения - определяем только часть точек которые будут летать\n  float mF = step(hp2, .3);\n  \n  // Дивгаем точки (те которые попали в mF, остальные на месте)\n  vpos.xyz = vpos.xyz + (vpos.xyz * fract(t)*2. ) * mF;\n  // Добавляем к отлетающей точке фактор плавающего смещения\n  vpos.xyz += nF * mF;\n  \n  gl_PointSize = pSize;\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4( vpos, 1.0 );\n}`,\n    });\n    \n\n    this.particleSystem = new THREE.Points(this.particles, this.pMaterial);\n    this.particleSystem.sortParticles = true;\n    \n    this.scene.add(this.particleSystem);\n\n    window.addEventListener('mousemove', this.handleMouseMove);\n    this.animate();\n  }\n\n  handleMouseMove = (e) => {\n    this.mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t  this.mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\n  }\n\n  animate = () => {\n    this.renderer.render( this.scene, this.camera );\n    this.pMaterial.uniforms.iTime.value = this.time * 0.175;\n    this.time++;\n    requestAnimationFrame( this.animate );\n  }\n  \n  render() {\n    return (\n      <div ref={(node) => { this.canvas = node}} />\n    );\n  }\n}"]},"metadata":{},"sourceType":"module"}