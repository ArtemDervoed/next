{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport fragmentShader from './fragment.glsl';\nimport vertexShader from './vertex.glsl';\nimport * as THREE from 'three';\nimport OrbitControls from 'three-orbitcontrols'; // import TRYGalien from './TRYGalien.woff2';\n\nexport default class Sphere extends React.PureComponent {\n  constructor() {\n    super();\n\n    _defineProperty(this, \"handleMouseMove\", e => {\n      this.mouse.x = e.clientX / window.innerWidth * 2 - 1;\n      this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n    });\n\n    _defineProperty(this, \"animate\", () => {\n      this.renderer.render(this.scene, this.camera);\n      this.pMaterial.uniforms.iTime.value = this.time * 0.175;\n      this.time++;\n      requestAnimationFrame(this.animate);\n    });\n\n    this.time = 0;\n    this.mouse = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  componentDidMount() {\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setClearColor('hsl(100, 10%, 10%)', 1);\n    this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);\n    this.camera.position.set(2, -1.5, -1);\n    this.camera.lookAt(new THREE.Vector3());\n    this.scene = new THREE.Scene();\n    this.camera.position.z = 5;\n    this.renderer.setSize(this.width, this.height);\n    this.canvas.appendChild(this.renderer.domElement);\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.controls.enableDamping = true;\n    this.controls.dampingFactor = 0.25;\n    this.controls.enableZoom = true;\n    this.particles = new THREE.OctahedronGeometry(1, 5);\n    this.particles.vertices = this.particles.vertices.map(v => {\n      v.x += (Math.random() - 0.5) * 0.05;\n      v.y += (Math.random() - 0.5) * 0.05;\n      v.z += (Math.random() - 0.5) * 0.05;\n      return v;\n    });\n    this.shaderPoint = THREE.ShaderLib.points;\n    this.uniforms = _objectSpread({}, this.shaderPoint.uniforms, {\n      iTime: {\n        value: 0\n      },\n      pSize: {\n        value: 10\n      }\n    });\n    this.pMaterial = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      transparent: true,\n      depthWrite: false,\n      blending: THREE.AdditiveBlending,\n      fragmentShader,\n      vertexShader\n    });\n    this.particleSystem = new THREE.Points(this.particles, this.pMaterial);\n    this.particleSystem.sortParticles = true;\n    this.scene.add(this.particleSystem);\n    window.addEventListener('mousemove', this.handleMouseMove);\n    this.animate();\n  }\n\n  render() {\n    return __jsx(\"div\", {\n      ref: node => {\n        this.canvas = node;\n      }\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}